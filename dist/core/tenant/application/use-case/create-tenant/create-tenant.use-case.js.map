{"version":3,"sources":["../../../../../../src/core/tenant/application/use-case/create-tenant/create-tenant.use-case.ts"],"sourcesContent":["import { IUseCase } from \"../../../../shared/application/use-case.interface\";\nimport { Tenant } from \"../../../domain/tenant.entity\";\nimport { ITenantRepository } from \"../../../domain/tenant.repository\";\nimport { TenantOutput, TenantOutputMapper } from \"../common/tenant-output\";\nimport { CreateTenantInput } from \"./create-tenant.input\";\n\nexport class CreateTenantUseCase implements IUseCase<CreateTenantInput, CreateTenantOutput> {\n\n  constructor(private readonly tenantRepo: ITenantRepository) { }\n\n\n  async execute(input: CreateTenantInput): Promise<CreateTenantOutput> {\n    const entity = Tenant.create(input);\n    await this.tenantRepo.insert(entity);\n    \n    /*\n    poderia retornar a entidade diretamente, mas isso faria que as camadas superiores conhecessem a \n    entidade que está em uma camada inferior, o que não é uma boa prática. Do ponto de vista prático \n    isso é uma problema uma vez que a alteração na entidade pode impactar em todas as camadas superiores\n    */\n    return TenantOutputMapper.toOutput(entity);\n  }\n}\n\n\nexport type CreateTenantOutput = TenantOutput;"],"names":["CreateTenantUseCase","execute","input","entity","Tenant","create","tenantRepo","insert","TenantOutputMapper","toOutput","constructor"],"mappings":";;;;+BAMaA;;;eAAAA;;;8BALU;8BAE0B;AAG1C,IAAA,AAAMA,sBAAN,MAAMA;IAKX,MAAMC,QAAQC,KAAwB,EAA+B;QACnE,MAAMC,SAASC,oBAAM,CAACC,MAAM,CAACH;QAC7B,MAAM,IAAI,CAACI,UAAU,CAACC,MAAM,CAACJ;QAE7B;;;;IAIA,GACA,OAAOK,gCAAkB,CAACC,QAAQ,CAACN;IACrC;IAbAO,YAAY,AAAiBJ,UAA6B,CAAE;aAA/BA,aAAAA;IAAiC;AAchE"}